###########<문제>##########
#11부터 20까지 숫자 만들고, 홀수만 뽑기
v1 = 11:20; v1

#index 이용
v1[c(1, 3, 5, 7, 9)]
v1[seq(1,10,by=2)] #seq함수로 1번째인덱스~10번째인덱스

#mask 이용
v1[]

#T/F 인덱스 이용->T에 해당하는 인덱스만 가져옴
v1[c(T,F,T,F,T,F,T,F,T,F)] #홀수를 가졍옴
v1[c(F,T,F,T,F,T,F,T,F,T)] #짝수를 가져옴

#rep() 함수 이용
v1[rep(c(T,F),length = 10)] #반복되는 T/F를 rep() 이용
v1[rep(c(T,F),times = 5)] #반복되는 T/F를 rep() 이용

#recycling rule (재활용) 이용
v1[c(T,F)] #T/F는 두개인데 인덱스가 안 맞게 된다.
#그렇기에 recycling으로 자동으로 T/F를 반복하게 된다

#인덱스 제거 이용
v1[-c(2, 4, 6, 8, 10)] # -를 붙이면 그 인덱스들 제거

#not 연산자 이용
v1[!c(F,T)] #boolean 형태이기 때문에 -를 쓸 수 없다.
#그렇기 때문에 not 연산자 사용

#나머지 연산자에서 몫만 가져오는 연산자
5%/%3 #몫만 가져옴옴
5%%3  #나머지만 가져옴