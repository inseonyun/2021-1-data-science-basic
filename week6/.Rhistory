v1 <- c(1, 2, 3)
v1
v1 = c(1, 2, 3)
v1
v1 = c(1:3)
, 2,
v1 = c(1, 2, 3)
v1
-5:5
#슬라이스 연산자 :
v2 = -5:5
v2
#슬라이스 연산자 :
v2 = 5:-5
v2
v3 = seq(1,10); v3
v3 = seq(v2); v3
v3 = seq(1,10); v3
seq(1, 10, 2)
seq(1,10,length=10)
seq(1,10,length=5)
letters[1]
letters[]
letters[1]
letters[11]
letters[13]
letters[1,3]
letters[1:3]
letters[c(1,2,3)]
letters[length(letters)]
length(letters)
toupper(letters[1:length(letters)])
#소문자로 변환해주는 함수 tolower
tolower(toupper(letters[1:length(letters)]))
#rep() 기존의 데이터는 있고, 그 데이터를 반복해서 저장
rep(1,3)
rep(1:3,3)
rep(c(1,4),3) #(1,4)를 3번 반복복
#rep() 기존의 데이터는 있고, 그 데이터를 반복해서 저장
rep(1,times = 3) #반복해야하는 수 1, 반복하는 횟수 3
rep(1:3, each = 3, times = 3)
rep(1:3,length=10)
rep('Hello', times=3)
length('Hello')
nchar('hello')
nchar(c(1,2,34))
seq(letters[1], letters[length(letters)], 2)
seq(1,26, 2)
seq(1,26, 3)
seq(1,26, 1)
seq(2,26, 2)
letters[seq(2,26, 2)]
toupper(letters[seq(2,26, 2)] )
toupper(a)
toupper('a')
rep(1:3,each=3,times=3) #each는 반복 숫자 하나하나를 3번씩 반복, times는 그 세트를 3번 반복
rep('Hello', times=3) #문자열을 3번 반복
letters[seq(2,length(letters), 2)] #짝수번째 알파벳 출력
toupper(letters[seq(2,length(letters), 2)])
#11부터 20까지 숫자 만들고, 홀수만 뽑기
v1 = 11:20; v1
v1 [c(1, 3, 5, 7, 9)]
v1[seq(1,10,by=2)]
#T/F 인덱스 이용
v1[c(T,F,T,F,T,F,T,F,T,F,T,F,T,F)]
#T/F 인덱스 이용
v1[c(T,F,T,F,T,F,T,F,T,F,T,F)]
#T/F 인덱스 이용
v1[c(T,F,T,F,T,F,T,F,T,F)]
v1
v1[c(F,T,F,T,F,T,F,T,F,T)]
v1[c(rep(1,10,1))]
v1[c(rep((T,F),10,1))]
v1[c(rep((T,F),10,1))]
v1[c(rep(c(T,F),10,1))]
v1[rep(c(T,F),10,1)]
v1[rep(c(T,F),length = 10)]
v1[rep(c(F,T),length = 10)] #반복되는 T/F를 rep() 이용
v1[rep(c(T,F),times = 5)] #반복되는 T/F를 rep() 이용
v1[c(T,F)]
#인덱스 제거 이용
v1[-c(2, 4, 6, 8, 10)]
#not 연산자 이용
vi[c(F,T)]
#not 연산자 이용
vi[c(T,F)]
F
#recycling rule (재활용) 이용
v1[c(T,F)] #T/F는 두개인데 인덱스가 안 맞게 된다.
#not 연산자 이용
v1[c(T,F)]
#not 연산자 이용
v1[c(F,T)]
#not 연산자 이용
v1[!c(F,T)]
#나머지 연산자에서 몫만 가져오는 연산자
5%/%3
5%%
5%%3
5%%3
#not 연산자 이용
v1[-c(F,T)] #boolean 형태이기 때문에 -를 쓸 수 없다.
#not 연산자 이용
v1[!c(F,T)] #boolean 형태이기 때문에 -를 쓸 수 없다.
v1
v1 %% 2
v1[v1%%2]
v1[v1%%2 == 1]
v1 %% 2
v1[v1%%2]
v1[v1%%2 == 1]
v1[v1%%2]
#나누기 연산자로 짝수만 출력
v1[v1%%2 !=1]
#나누기 연산자로 짝수만 출력
v1[!(v1%%2 ==1) ]
v1[v1%%2 != 1]
#비교연산 (recycling rule 이용)
c(3, 1) >=2
#짝수번째 알파벳을 출력
v1 = 1:10;v1
letters[v1%%2 ==0]
letters[(1:10)%%2 == 0]
v1%%2 ==0
letters[(1:2)%%2 == 0]
letters[(1:10)%%2 == 0]
#연산자 우선순위 정해주기
3+4*2
(3+4)*2
v1 = c(1,2,3)
v2 = c('A','B','C')
cbind(v1,v2)
rbind(v1, v2)
colnames(m1) #col 열의 이름을 따로 지정해줌
m1 = cbind(v1,v2)
m2 = rbind(v1, v2)
colnames(m1) #col 열의 이름을 따로 지정해줌
colnames(m1) #col 열의 이름을 따로 지정해줌
#col 열의 이름을 따로 지정해줌
colnames(m1) = c('숫자','문자')
#col 열의 이름을 따로 지정해줌
colnames(m1) = c('숫자','문자')
#col 열의 이름을 따로 지정해줌
colnames(m1) = c('숫자','문자'); m1
#row 열의 이름을 따로 지정해줌
rownames(m2) = c('천원','이천원','삼천원'); m2
#row 열의 이름을 따로 지정해줌
rownames(m2) = c('천원','이천원'); m2
m2
#col 열의 이름을 따로 지정해줌
colnames(m1) = c('숫자','문자'); m1
m3 = rbind(c2,c3); m3
###문제###
#3개의 입력값 c(1600, 2700, 3900)에 대해 거스름돈 500원 100원의 개수를 표현해라
c2 = c(1600%/%500,2700%/%500, 3900%/%500)
c3 = c((1600%%500)%/%100, (2700)%/%100,(3900)%/%100))
c3 = c((1600%%500)%/%100, (2700%%500)%/%100,(3900%%500)%/%100)
m3 = rbind(c2,c3); m3
m3 = cbind(c2,c3); m3
colnames(m3) = c('500원','100원')
rownames(m3) = c('1600원','2700원','3900원'); m3
